<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_neyu_rest_utils.RequestBuilder</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>RequestBuilder</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[var RequestBuilder = Class.create();
RequestBuilder.prototype = {
    initialize: function(config) {
        this.debug = gs.getProperty("x_neyu_rest_utils.debug", "false") == "true";
        this.config = !gs.nil(config) ? {
            ...config
        } : {};
    },

    /**
     * Main entrypoint for the API, uses the config object
     * to build and authenticate a RESTMessageV2 object
     * 
     * @param requestConfig {object} - object containing required configuration information
     * @return RESTMessageV2 object.
     */
    build: function(requestConfig) {
        const config = !gs.nil(requestConfig) ? {
            ...requestConfig
        } : this.config;

        if (gs.nil(config) || Object.keys(config).length == 0) {
            throw "config must be defined";
        }
        if (this.debug) {
            gs.debug("[build] config:\n" + JSON.stringify(config));
        }
        if (gs.nil(config["aliasId"])) {
            throw "Connection & Credential alias must be defined.";
        }

        const aliasID = config["aliasId"];
        const path = config["path"] ? config["path"] : null;
        const method = config["httpMethod"] ? config["httpMethod"] : null;
        const content = config["content"] ? config["content"] : null;
        const pathParams = config["pathParams"] ? config["pathParams"] : {};
        const queryParams = config["queryParams"] ? config["queryParams"] : {};
        const headers = config["headers"] ? config["headers"] : {};
        const topics = config["topics"] ? config["topics"] : {};

        const connectionInfo = this.getConnectionInfo(aliasID);

        const authCredential = this.getCredentialForAlias(aliasID);
        // let authCredential;
        // try {
        //     authCredential = this.getCredential(connectionInfo.getCredentialAttribute("sys_id"));
        //     if (gs.nil(authCredential)) {
        //         throw new Error("falling back to GlobalCredentialUtil");
        //     }
        // } catch (ex) {
        //     gs.warn("[build] Exception getting the credential: " + ex);
        //     try {
        //         authCredential = this._globalGetCredential(aliasID);
        //     } catch (e) {
        //         gs.error("[build] _globalGetCredential failed: " + e);
        //         throw e;
        //     }
        // }

        const httpRequestData = this.buildRequest(
            connectionInfo.getAttribute("connection_url") + path, // construct endpoint from connection info base + method specific part
            method,
            content,
            pathParams,
            queryParams,
            headers
        );

        const signedRequest = this.signRequest(httpRequestData, authCredential);
        if (signedRequest != null && this.debug) {
            gs.debug("[build] Signing Status:\nStatus: " + signedRequest.getStatus() + "\nMessage: " +
                signedRequest.getStatusMessage());
        }
        if (signedRequest.getStatus().toLowerCase() != "success") {
            let error = "Error signing HTTP request." +
                "\nStatus: " + signedRequest.getStatus() +
                "\nMessage: " + signedRequest.getStatusMessage();
            throw error;
        }

        if (this.debug) {
            gs.debug("Build Request, generating REST Message");
        }
        return this.generateRestMessage(httpRequestData, signedRequest, connectionInfo, topics);
    },

    /**
     * Given sn_auth.HttpRequestData and sn_auth.HttpRequestAuthedData objects
     * builds a RESTMessageV2 object.
     * 
     * @param httpRequestData {HttpRequestData} - object describing the request
     * @param signedRequest {HttpRequestAuthedData} - signed object with auth info
     * @param connectionInfo {ConnectionInfo} - Connection & Credential Alias connection info
     * @param topics {object} - optional map of ECC Topic names and values
     * @return RESTMessageV2 object
     */
    generateRestMessage: function(httpRequestData, signedRequest, connectionInfo, topics = {}) {
        if (this.debug) {
            gs.debug("Creating RESTMessaveV2:\nhttpREquestData: " + httpRequestData +
                "\nsignedRequest: " + signedRequest + "\nconnectionInfo: " + connectionInfo);
        }
        const restMessage = new sn_ws.RESTMessageV2();

        let endpoint = httpRequestData.getEndpoint();
        // append queryparams to the endpoint because setQueryParameter on RESTMessageV2
        // appears to be broken
        if (Object.keys(httpRequestData.getQueryParamMap()).length > 0) {
            endpoint += "?";
            Object.entries(httpRequestData.getQueryParamMap()).forEach(([key, value]) => {
                endpoint += key + "=" + value + "&";
            });
            // remove trailing '&'
            if (endpoint.endsWith("&")) {
                endpoint = endpoint.substr(0, endpoint.length - 1);
            }
        }

        restMessage.setEndpoint(endpoint);
        restMessage.setHttpMethod(httpRequestData.getHttpMethod());

        // set request headers
        Object
            .entries(httpRequestData.getHeaderMap())
            .forEach(([key, value]) => restMessage.setRequestHeader(key, value));

        // set topics
        Object
            .entries(topics)
            .forEach(([key, value]) => restMessage.setEccParameter(key, value));

        const directive = signedRequest.getDirective().toLowerCase();
        if (directive == "header") {
            Object
                .entries(signedRequest.getHeaderMap())
                .forEach(([key, value]) => restMessage.setRequestHeader(key, value));
        } else if (directive == "query") {
            if (!endpoint.includes("?")) {
                endpoint += "?";
            }
            Object
                .entries(signedRequest.getQueryMap())
                .forEach(([key, value]) => {
                    endpoint += key + "=" + value + "&";
                });
            // remove trailing '&'
            if (endpoint.endsWith("&")) {
                endpoint = endpoint.substr(0, endpoint.length - 1);
            }
        } else {
            // directive credential_value
            throw "The directive " + directive + " is not currently supported";
        }

        // set MID server if Use Mid is true
        const mid = this.getMidForConnection(connectionInfo);
        if (!gs.nil(mid)) {
            if (this.debug) {
                gs.debug("[generateRestMessage] MID found: " + mid);
            }

            restMessage.setMIDServer(mid);
        }

        if (this.debug) {
            gs.debug("Returning built RESTMessageV2:" +
                "\nEndpint: " + restMessage.getEndpoint() +
                "\nHeaders: " + JSON.stringify(restMessage.getRequestHeaders()));
        }
        return restMessage;
    },

    /**
     * Builds an sn_auth.HttpRequestData object
     */
    buildRequest: function(
        endpoint,
        httpMethod = "GET",
        content = null,
        pathParams = {},
        queryParams = {},
        headers = {}
    ) {
        if (this.debug) {
            gs.debug("[buildRequest] Inputs:" +
                "\nendpoint: " + endpoint +
                "\nhttpMethod: " + httpMethod +
                "\ncontent: " + content +
                "\npathParams: " + JSON.stringify(pathParams) +
                "\nqueryParams: " + JSON.stringify(queryParams) +
                "\nheaders: " + JSON.stringify(headers));
        }

        if (gs.nil(endpoint)) {
            gs.error("[buildRequest] endpoint cannot be empty");
            throw "Endpoint cannot be empty";
        }

        const httpRequestData = new sn_auth.HttpRequestData();
        // both Basic and OAuth2 utilize headers for authentication
        httpRequestData.setDirective("header");
        // set HTTP Method
        httpRequestData.setHttpMethod(httpMethod);
        // set request content
        if (!gs.nil(content)) {
            httpRequestData.setContent(content);
        }

        // replace path parameter placeholders '${key}' with value
        Object.entries(pathParams).forEach(([key, value]) => {
            endpoint = endpoint.replace("${" + key + "}", value);
        });
        httpRequestData.setEndpoint(endpoint);

        // set queryParameters
        Object.entries(queryParams)
            .forEach(([key, value]) => httpRequestData.addQueryParam(key, value));

        // set headers
        Object.entries(headers)
            .forEach(([key, value]) => httpRequestData.addHeader(key, value));

        return httpRequestData;
    },

    /**
     * Retrieves the sn_auth.AuthCredential object given a credential SYS_ID.
     * Should only be used when executing from a System/Background context
     * 
     * @param credentialID {string} - sys_id of the credential record
     * @Return sn_auth.AuthCredential object
     */
    getCredential: function(credentialID) {
        if (this.debug) {
            gs.debug("[getCredential] for id: " + credentialID);
        }
        if (gs.nil(credentialID)) {
            throw "Must provide credentialID for getCredential";
        }
        var regexp = /[0-9a-f]{32}/;
        if (!regexp.test(credentialID)) {
            throw new Error("credentialID must be a valid sys_id");
        }
        return new sn_cc.StandardCredentialsProvider().getAuthCredentialByID(credentialID);
    },

    getCredentialForAlias: function(aliasID) {
        if (this.debug) {
            gs.debug("[getCredentialForAlias] for id: " + aliasID);
        }
        if (gs.nil(aliasID)) {
            throw "Must provide aliasID for getCredentialForAlias";
        }
        var regexp = /[0-9a-f]{32}/;
        if (!regexp.test(aliasID)) {
            throw new Error("aliasID must be a valid sys_id");
        }
        return this._globalGetCredential(aliasID);
    },

    _globalGetCredential: function(aliasID) {
        if (this.debug) {
            gs.debug("[_globalGetCredential] Calling GlobalCredentialUtil");
        }
        return new global.GlobalCredentialUtil()
            .getAuthCredentialForAlias(aliasID);
    },

    signRequest: function(requestData, credential) {
        // Calls the Signing configuration defined in the credential's auth_algorithm
        // field
        const signingAPI = new sn_auth.RequestAuthAPI(requestData, credential);
        return signingAPI.generateAuth(signingAPI);
    },

    /**
     * Retrieves the ConnectionInfo object associated with the App's Connection & 
     * Credential alias
     * 
     * @param aliasID {string} - sys_id of the Connection & Credential Alias
     * @return ConnectionInfo
     */
    getConnectionInfo: function(aliasID) {
        const provider = new sn_cc.ConnectionInfoProvider();
        const connectionInfo = provider.getConnectionInfo(aliasID);

        if (connectionInfo != null) {
            return connectionInfo;
        } else {
            gs.warn("Unable to retrieve connection & credential alias for alias id: " +
                aliasID + "\nFalling Back to GlobalCredentialUtil");
            return this._getConnectionInfoFacade(aliasID);
        }
    },

    // separated into its own method call to facilitate ATF
    _getConnectionInfoFacade: function(aliasID) {
        return new global.GlobalCredentialUtil()
            .getConnectionInfoFacade(aliasID);
    },

    /**
     * If MID capabilities have been specified for the Connection record,
     * returns the name of a capable MID server.
     * 
     * @param connectionInfo {sn_cc.ConnectionInfo} the active connection record
     * @return MID server name or null
     */
    getMidForConnection: function(connectionInfo) {
        if (connectionInfo == null) {
            gs.error("[getMidForConnection] ConnectionInfo object cannot be null");
            return;
        }
        // ConnectionInfo and ConnectionInfoFacade have slightly different attributes
		const useMid = connectionInfo.getAttribute("use_mid") + "";
        if (useMid == "true") {
            if (this.debug) {
                gs.debug("[getMidForConnection] use_mid was true");
            }
            const mid = this._getCapableMidServer(
                connectionInfo.getCredentialAttribute("applies_to"),
                connectionInfo.getCredentialAttribute("mid_list")
            );
            if (!gs.nil(mid)) {
                return mid;
            } else {
                if (this.debug) {
                    gs.debug("Falling back to global.GlobalMIDSelector for MID Selection");
                }
                return new global.GlobalMIDSelector()
                    .findByCapabilities(
                        connectionInfo.getAttribute("capabilities")
                    );
            }
        } else {
            if (this.debug) {
                gs.debug("[getMidForConnection] use_mid was false");
            }
            return "";
        }
    },

    _getCapableMidServer: function(appliesTo, midList) {
        // tricksy undocumented APIs
        const mid = new sn_auth.OAuthMidSelector().selectRESTCapableMidServer(appliesTo, midList);
        if (this.debug) {
            gs.debug("[_getCapabileMidServer] returned MID: " + mid);
        }
        return mid;
    },


    type: 'RequestBuilder'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>ab7289</sys_created_by>
        <sys_created_on>2025-07-01 17:17:19</sys_created_on>
        <sys_id>0477c060eb2aa6105c06fcffcad0cd14</sys_id>
        <sys_mod_count>64</sys_mod_count>
        <sys_name>RequestBuilder</sys_name>
        <sys_package display_value="REST Utils" source="x_neyu_rest_utils">6146c020eb2aa6105c06fcffcad0cd6f</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="REST Utils">6146c020eb2aa6105c06fcffcad0cd6f</sys_scope>
        <sys_update_name>sys_script_include_0477c060eb2aa6105c06fcffcad0cd14</sys_update_name>
        <sys_updated_by>ab7289</sys_updated_by>
        <sys_updated_on>2025-09-24 16:03:50</sys_updated_on>
    </sys_script_include>
</record_update>
